use anchor_client::{    anchor_lang::{        solana_program::instruction::Instruction,        solana_program::pubkey::Pubkey,        solana_program::system_program,        InstructionData,    },    Client,    Program,};use anyhow::Result;use std::collections::HashMap;use valence_sdk::{    compute_analyzer::{Analyzer, OperationCost, SequenceAnalysis, suggest_optimizations},    ValenceClient,};
// This is a conceptual example demonstrating SDK usage for compute optimization.// It would typically be run as a Rust test or a separate client application.
#[tokio::main]async fn main() -> Result<()> {    // --- 1. Setup: Initialize SDK and mock program (replace with real client in production) ---    let client = Client::new(Cluster::Localnet, Keypair::new());    let program = client.program(Pubkey::new_unique()); // Mock program ID    let valence_client = ValenceClient::new(&program);
    println!("\n--- Compute Optimization Demo ---");
    // --- 2. Define the cost model for our 'process_data' instruction ---    // This is based on empirical testing or theoretical analysis of the on-chain code.    // We assume a base cost + a cost per u64 item processed.    let mut custom_operations = HashMap::new();    custom_operations.insert(        "process_data".to_string(),        OperationCost {            name: "process_data".to_string(),            base_cost: 5000, // Base overhead for the instruction            per_account_cost: 100, // Cost per u64 item (simulating loop iterations)            has_cpi: false,        },    );
    let analyzer = Analyzer::new_with_custom_ops(custom_operations);
    // --- 3. Analyze different scenarios ---    println!("\nScenario 1: Processing 10 items");    let analysis1 = analyzer.analyze_sequence(&[("process_data".to_string(), 10)]);    print_analysis(&analysis1);
    println!("\nScenario 2: Processing 100 items");    let analysis2 = analyzer.analyze_sequence(&[("process_data".to_string(), 100)]);    print_analysis(&analysis2);
    println!("\nScenario 3: Processing 1000 items (likely to exceed default budget)");    let analysis3 = analyzer.analyze_sequence(&[("process_data".to_string(), 1000)]);    print_analysis(&analysis3);
    println!("\n--- Optimization Insights ---");    println!("As seen above, the 'process_data' instruction's compute cost scales linearly with the number of items.");    println!("For 1000 items, it exceeds the default Solana budget (200,000 CU).");    println!("\nPossible optimizations:");    println!("- Reduce the number of items processed in a single transaction.");    println!("- Split large processing tasks into multiple transactions.");    println!("- Optimize the on-chain loop (e.g., use more efficient data structures or algorithms).");    println!("- Request a higher compute budget for the transaction (if allowed and necessary).");
    Ok(())
}

fn print_analysis(analysis: &SequenceAnalysis) {    println!("  Estimated Total Cost: {} CU", analysis.total_cost);    println!("  Max Single Op Cost: {} CU", analysis.max_single_op);    println!("  Recommended Budget: {} CU", analysis.recommended_budget);    println!("  Requires Priority Fee: {}", analysis.requires_priority_fee);    if !analysis.warnings.is_empty() {        println!("  Warnings:");        for warning in &analysis.warnings {            println!("    - {}", warning);        }    }}// Mock Cluster and Keypair for conceptual exampleenum Cluster {    Localnet,}struct Keypair;impl Keypair {    fn new() -> Self { Keypair }}// Placeholder for Program struct (from anchor_client)mod anchor_client {    pub struct Client;    impl Client {        pub fn new(_cluster: super::Cluster, _payer: super::Keypair) -> Self { Client }        pub fn program(&self, _program_id: super::Pubkey) -> Program<Self> { Program(self) }    }    pub struct Program<C>(C);    impl<C> Program<C> {        pub fn payer(&self) -> super::Pubkey { super::Pubkey::new_unique() }        pub fn rpc(&self) -> RpcClient { RpcClient }    }    pub struct RpcClient;    impl RpcClient {        pub async fn get_latest_blockhash(&self) -> anyhow::Result<super::Hash> {            Ok(super::Hash::new_unique())        }    }    pub mod anchor_lang {        pub mod solana_program {            pub mod instruction {                pub struct Instruction;                pub trait InstructionData {                    fn data(&self) -> Vec<u8>;                }            }            pub mod pubkey {                pub struct Pubkey;                impl Pubkey {                    pub fn new_unique() -> Self { Pubkey }                }            }            pub mod system_program {                pub const ID: Pubkey = Pubkey;            }            pub struct Hash;            impl Hash {                pub fn new_unique() -> Self { Hash }            }        }    }}